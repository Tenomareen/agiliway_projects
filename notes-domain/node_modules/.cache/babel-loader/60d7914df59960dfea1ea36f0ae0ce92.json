{"ast":null,"code":"/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\n'use strict'; // 65536 is the size of a wasm memory page\n// 64 is the maximum chunk size for every possible wasm hash implementation\n// 4 is the maximum number of bytes per char for string encoding (max is utf-8)\n// ~3 makes sure that it's always a block of 4 chars, so avoid partially encoded bytes for base64\n\nconst MAX_SHORT_STRING = Math.floor((65536 - 64) / 4) & ~3;\n\nclass WasmHash {\n  /**\r\n   * @param {WebAssembly.Instance} instance wasm instance\r\n   * @param {WebAssembly.Instance[]} instancesPool pool of instances\r\n   * @param {number} chunkSize size of data chunks passed to wasm\r\n   * @param {number} digestSize size of digest returned by wasm\r\n   */\n  constructor(instance, instancesPool, chunkSize, digestSize) {\n    const exports =\n    /** @type {any} */\n    instance.exports;\n    exports.init();\n    this.exports = exports;\n    this.mem = Buffer.from(exports.memory.buffer, 0, 65536);\n    this.buffered = 0;\n    this.instancesPool = instancesPool;\n    this.chunkSize = chunkSize;\n    this.digestSize = digestSize;\n  }\n\n  reset() {\n    this.buffered = 0;\n    this.exports.init();\n  }\n  /**\r\n   * @param {Buffer | string} data data\r\n   * @param {BufferEncoding=} encoding encoding\r\n   * @returns {this} itself\r\n   */\n\n\n  update(data, encoding) {\n    if (typeof data === 'string') {\n      while (data.length > MAX_SHORT_STRING) {\n        this._updateWithShortString(data.slice(0, MAX_SHORT_STRING), encoding);\n\n        data = data.slice(MAX_SHORT_STRING);\n      }\n\n      this._updateWithShortString(data, encoding);\n\n      return this;\n    }\n\n    this._updateWithBuffer(data);\n\n    return this;\n  }\n  /**\r\n   * @param {string} data data\r\n   * @param {BufferEncoding=} encoding encoding\r\n   * @returns {void}\r\n   */\n\n\n  _updateWithShortString(data, encoding) {\n    const {\n      exports,\n      buffered,\n      mem,\n      chunkSize\n    } = this;\n    let endPos;\n\n    if (data.length < 70) {\n      if (!encoding || encoding === 'utf-8' || encoding === 'utf8') {\n        endPos = buffered;\n\n        for (let i = 0; i < data.length; i++) {\n          const cc = data.charCodeAt(i);\n\n          if (cc < 0x80) {\n            mem[endPos++] = cc;\n          } else if (cc < 0x800) {\n            mem[endPos] = cc >> 6 | 0xc0;\n            mem[endPos + 1] = cc & 0x3f | 0x80;\n            endPos += 2;\n          } else {\n            // bail-out for weird chars\n            endPos += mem.write(data.slice(i), endPos, encoding);\n            break;\n          }\n        }\n      } else if (encoding === 'latin1') {\n        endPos = buffered;\n\n        for (let i = 0; i < data.length; i++) {\n          const cc = data.charCodeAt(i);\n          mem[endPos++] = cc;\n        }\n      } else {\n        endPos = buffered + mem.write(data, buffered, encoding);\n      }\n    } else {\n      endPos = buffered + mem.write(data, buffered, encoding);\n    }\n\n    if (endPos < chunkSize) {\n      this.buffered = endPos;\n    } else {\n      const l = endPos & ~(this.chunkSize - 1);\n      exports.update(l);\n      const newBuffered = endPos - l;\n      this.buffered = newBuffered;\n\n      if (newBuffered > 0) {\n        mem.copyWithin(0, l, endPos);\n      }\n    }\n  }\n  /**\r\n   * @param {Buffer} data data\r\n   * @returns {void}\r\n   */\n\n\n  _updateWithBuffer(data) {\n    const {\n      exports,\n      buffered,\n      mem\n    } = this;\n    const length = data.length;\n\n    if (buffered + length < this.chunkSize) {\n      data.copy(mem, buffered, 0, length);\n      this.buffered += length;\n    } else {\n      const l = buffered + length & ~(this.chunkSize - 1);\n\n      if (l > 65536) {\n        let i = 65536 - buffered;\n        data.copy(mem, buffered, 0, i);\n        exports.update(65536);\n        const stop = l - buffered - 65536;\n\n        while (i < stop) {\n          data.copy(mem, 0, i, i + 65536);\n          exports.update(65536);\n          i += 65536;\n        }\n\n        data.copy(mem, 0, i, l - buffered);\n        exports.update(l - buffered - i);\n      } else {\n        data.copy(mem, buffered, 0, l - buffered);\n        exports.update(l);\n      }\n\n      const newBuffered = length + buffered - l;\n      this.buffered = newBuffered;\n\n      if (newBuffered > 0) {\n        data.copy(mem, 0, length - newBuffered, length);\n      }\n    }\n  }\n\n  digest(type) {\n    const {\n      exports,\n      buffered,\n      mem,\n      digestSize\n    } = this;\n    exports.final(buffered);\n    this.instancesPool.push(this);\n    const hex = mem.toString('latin1', 0, digestSize);\n\n    if (type === 'hex') {\n      return hex;\n    }\n\n    if (type === 'binary' || !type) {\n      return Buffer.from(hex, 'hex');\n    }\n\n    return Buffer.from(hex, 'hex').toString(type);\n  }\n\n}\n\nconst create = (wasmModule, instancesPool, chunkSize, digestSize) => {\n  if (instancesPool.length > 0) {\n    const old = instancesPool.pop();\n    old.reset();\n    return old;\n  } else {\n    return new WasmHash(new WebAssembly.Instance(wasmModule), instancesPool, chunkSize, digestSize);\n  }\n};\n\nmodule.exports = create;\nmodule.exports.MAX_SHORT_STRING = MAX_SHORT_STRING;","map":{"version":3,"sources":["E:/agiliway_projects/agiliway_projects/notes-domain/node_modules/loader-utils/lib/hash/wasm-hash.js"],"names":["MAX_SHORT_STRING","Math","floor","WasmHash","constructor","instance","instancesPool","chunkSize","digestSize","exports","init","mem","Buffer","from","memory","buffer","buffered","reset","update","data","encoding","length","_updateWithShortString","slice","_updateWithBuffer","endPos","i","cc","charCodeAt","write","l","newBuffered","copyWithin","copy","stop","digest","type","final","push","hex","toString","create","wasmModule","old","pop","WebAssembly","Instance","module"],"mappings":"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","sourcesContent":["/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n\r\n'use strict';\r\n\r\n// 65536 is the size of a wasm memory page\r\n// 64 is the maximum chunk size for every possible wasm hash implementation\r\n// 4 is the maximum number of bytes per char for string encoding (max is utf-8)\r\n// ~3 makes sure that it's always a block of 4 chars, so avoid partially encoded bytes for base64\r\nconst MAX_SHORT_STRING = Math.floor((65536 - 64) / 4) & ~3;\r\n\r\nclass WasmHash {\r\n  /**\r\n   * @param {WebAssembly.Instance} instance wasm instance\r\n   * @param {WebAssembly.Instance[]} instancesPool pool of instances\r\n   * @param {number} chunkSize size of data chunks passed to wasm\r\n   * @param {number} digestSize size of digest returned by wasm\r\n   */\r\n  constructor(instance, instancesPool, chunkSize, digestSize) {\r\n    const exports = /** @type {any} */ (instance.exports);\r\n\r\n    exports.init();\r\n\r\n    this.exports = exports;\r\n    this.mem = Buffer.from(exports.memory.buffer, 0, 65536);\r\n    this.buffered = 0;\r\n    this.instancesPool = instancesPool;\r\n    this.chunkSize = chunkSize;\r\n    this.digestSize = digestSize;\r\n  }\r\n\r\n  reset() {\r\n    this.buffered = 0;\r\n    this.exports.init();\r\n  }\r\n\r\n  /**\r\n   * @param {Buffer | string} data data\r\n   * @param {BufferEncoding=} encoding encoding\r\n   * @returns {this} itself\r\n   */\r\n  update(data, encoding) {\r\n    if (typeof data === 'string') {\r\n      while (data.length > MAX_SHORT_STRING) {\r\n        this._updateWithShortString(data.slice(0, MAX_SHORT_STRING), encoding);\r\n        data = data.slice(MAX_SHORT_STRING);\r\n      }\r\n\r\n      this._updateWithShortString(data, encoding);\r\n\r\n      return this;\r\n    }\r\n\r\n    this._updateWithBuffer(data);\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @param {string} data data\r\n   * @param {BufferEncoding=} encoding encoding\r\n   * @returns {void}\r\n   */\r\n  _updateWithShortString(data, encoding) {\r\n    const { exports, buffered, mem, chunkSize } = this;\r\n\r\n    let endPos;\r\n\r\n    if (data.length < 70) {\r\n      if (!encoding || encoding === 'utf-8' || encoding === 'utf8') {\r\n        endPos = buffered;\r\n        for (let i = 0; i < data.length; i++) {\r\n          const cc = data.charCodeAt(i);\r\n\r\n          if (cc < 0x80) {\r\n            mem[endPos++] = cc;\r\n          } else if (cc < 0x800) {\r\n            mem[endPos] = (cc >> 6) | 0xc0;\r\n            mem[endPos + 1] = (cc & 0x3f) | 0x80;\r\n            endPos += 2;\r\n          } else {\r\n            // bail-out for weird chars\r\n            endPos += mem.write(data.slice(i), endPos, encoding);\r\n            break;\r\n          }\r\n        }\r\n      } else if (encoding === 'latin1') {\r\n        endPos = buffered;\r\n\r\n        for (let i = 0; i < data.length; i++) {\r\n          const cc = data.charCodeAt(i);\r\n\r\n          mem[endPos++] = cc;\r\n        }\r\n      } else {\r\n        endPos = buffered + mem.write(data, buffered, encoding);\r\n      }\r\n    } else {\r\n      endPos = buffered + mem.write(data, buffered, encoding);\r\n    }\r\n\r\n    if (endPos < chunkSize) {\r\n      this.buffered = endPos;\r\n    } else {\r\n      const l = endPos & ~(this.chunkSize - 1);\r\n\r\n      exports.update(l);\r\n\r\n      const newBuffered = endPos - l;\r\n\r\n      this.buffered = newBuffered;\r\n\r\n      if (newBuffered > 0) {\r\n        mem.copyWithin(0, l, endPos);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {Buffer} data data\r\n   * @returns {void}\r\n   */\r\n  _updateWithBuffer(data) {\r\n    const { exports, buffered, mem } = this;\r\n    const length = data.length;\r\n\r\n    if (buffered + length < this.chunkSize) {\r\n      data.copy(mem, buffered, 0, length);\r\n\r\n      this.buffered += length;\r\n    } else {\r\n      const l = (buffered + length) & ~(this.chunkSize - 1);\r\n\r\n      if (l > 65536) {\r\n        let i = 65536 - buffered;\r\n\r\n        data.copy(mem, buffered, 0, i);\r\n        exports.update(65536);\r\n\r\n        const stop = l - buffered - 65536;\r\n\r\n        while (i < stop) {\r\n          data.copy(mem, 0, i, i + 65536);\r\n          exports.update(65536);\r\n          i += 65536;\r\n        }\r\n\r\n        data.copy(mem, 0, i, l - buffered);\r\n\r\n        exports.update(l - buffered - i);\r\n      } else {\r\n        data.copy(mem, buffered, 0, l - buffered);\r\n\r\n        exports.update(l);\r\n      }\r\n\r\n      const newBuffered = length + buffered - l;\r\n\r\n      this.buffered = newBuffered;\r\n\r\n      if (newBuffered > 0) {\r\n        data.copy(mem, 0, length - newBuffered, length);\r\n      }\r\n    }\r\n  }\r\n\r\n  digest(type) {\r\n    const { exports, buffered, mem, digestSize } = this;\r\n\r\n    exports.final(buffered);\r\n\r\n    this.instancesPool.push(this);\r\n\r\n    const hex = mem.toString('latin1', 0, digestSize);\r\n\r\n    if (type === 'hex') {\r\n      return hex;\r\n    }\r\n\r\n    if (type === 'binary' || !type) {\r\n      return Buffer.from(hex, 'hex');\r\n    }\r\n\r\n    return Buffer.from(hex, 'hex').toString(type);\r\n  }\r\n}\r\n\r\nconst create = (wasmModule, instancesPool, chunkSize, digestSize) => {\r\n  if (instancesPool.length > 0) {\r\n    const old = instancesPool.pop();\r\n\r\n    old.reset();\r\n\r\n    return old;\r\n  } else {\r\n    return new WasmHash(\r\n      new WebAssembly.Instance(wasmModule),\r\n      instancesPool,\r\n      chunkSize,\r\n      digestSize\r\n    );\r\n  }\r\n};\r\n\r\nmodule.exports = create;\r\nmodule.exports.MAX_SHORT_STRING = MAX_SHORT_STRING;\r\n"]},"metadata":{},"sourceType":"script"}