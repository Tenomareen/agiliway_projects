{"ast":null,"code":"'use strict';\n\nconst baseEncodeTables = {\n  26: 'abcdefghijklmnopqrstuvwxyz',\n  32: '123456789abcdefghjkmnpqrstuvwxyz',\n  // no 0lio\n  36: '0123456789abcdefghijklmnopqrstuvwxyz',\n  49: 'abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ',\n  // no lIO\n  52: 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ',\n  58: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ',\n  // no 0lIO\n  62: '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ',\n  64: '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_'\n};\n\nfunction encodeBufferToBase(buffer, base) {\n  const encodeTable = baseEncodeTables[base];\n\n  if (!encodeTable) {\n    throw new Error('Unknown encoding base' + base);\n  }\n\n  const readLength = buffer.length;\n\n  const Big = require('big.js');\n\n  Big.RM = Big.DP = 0;\n  let b = new Big(0);\n\n  for (let i = readLength - 1; i >= 0; i--) {\n    b = b.times(256).plus(buffer[i]);\n  }\n\n  let output = '';\n\n  while (b.gt(0)) {\n    output = encodeTable[b.mod(base)] + output;\n    b = b.div(base);\n  }\n\n  Big.DP = 20;\n  Big.RM = 1;\n  return output;\n}\n\nlet createMd4 = undefined;\nlet BatchedHash = undefined;\n\nfunction getHashDigest(buffer, hashType, digestType, maxLength) {\n  hashType = hashType || 'md4';\n  maxLength = maxLength || 9999;\n  let hash;\n\n  try {\n    hash = require('crypto').createHash(hashType);\n  } catch (error) {\n    if (error.code === 'ERR_OSSL_EVP_UNSUPPORTED' && hashType === 'md4') {\n      if (createMd4 === undefined) {\n        createMd4 = require('./hash/md4');\n\n        if (BatchedHash === undefined) {\n          BatchedHash = require('./hash/BatchedHash');\n        }\n      }\n\n      hash = new BatchedHash(createMd4());\n    }\n\n    if (!hash) {\n      throw error;\n    }\n  }\n\n  hash.update(buffer);\n\n  if (digestType === 'base26' || digestType === 'base32' || digestType === 'base36' || digestType === 'base49' || digestType === 'base52' || digestType === 'base58' || digestType === 'base62') {\n    return encodeBufferToBase(hash.digest(), digestType.substr(4)).substr(0, maxLength);\n  } else {\n    return hash.digest(digestType || 'hex').substr(0, maxLength);\n  }\n}\n\nmodule.exports = getHashDigest;","map":{"version":3,"sources":["E:/agiliway_projects/agiliway_projects/notes-domain/node_modules/loader-utils/lib/getHashDigest.js"],"names":["baseEncodeTables","encodeBufferToBase","buffer","base","encodeTable","Error","readLength","length","Big","require","RM","DP","b","i","times","plus","output","gt","mod","div","createMd4","undefined","BatchedHash","getHashDigest","hashType","digestType","maxLength","hash","createHash","error","code","update","digest","substr","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nconst baseEncodeTables = {\r\n  26: 'abcdefghijklmnopqrstuvwxyz',\r\n  32: '123456789abcdefghjkmnpqrstuvwxyz', // no 0lio\r\n  36: '0123456789abcdefghijklmnopqrstuvwxyz',\r\n  49: 'abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ', // no lIO\r\n  52: 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ',\r\n  58: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ', // no 0lIO\r\n  62: '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ',\r\n  64: '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_',\r\n};\r\n\r\nfunction encodeBufferToBase(buffer, base) {\r\n  const encodeTable = baseEncodeTables[base];\r\n  if (!encodeTable) {\r\n    throw new Error('Unknown encoding base' + base);\r\n  }\r\n\r\n  const readLength = buffer.length;\r\n  const Big = require('big.js');\r\n\r\n  Big.RM = Big.DP = 0;\r\n  let b = new Big(0);\r\n\r\n  for (let i = readLength - 1; i >= 0; i--) {\r\n    b = b.times(256).plus(buffer[i]);\r\n  }\r\n\r\n  let output = '';\r\n  while (b.gt(0)) {\r\n    output = encodeTable[b.mod(base)] + output;\r\n    b = b.div(base);\r\n  }\r\n\r\n  Big.DP = 20;\r\n  Big.RM = 1;\r\n\r\n  return output;\r\n}\r\n\r\nlet createMd4 = undefined;\r\nlet BatchedHash = undefined;\r\n\r\nfunction getHashDigest(buffer, hashType, digestType, maxLength) {\r\n  hashType = hashType || 'md4';\r\n  maxLength = maxLength || 9999;\r\n\r\n  let hash;\r\n\r\n  try {\r\n    hash = require('crypto').createHash(hashType);\r\n  } catch (error) {\r\n    if (error.code === 'ERR_OSSL_EVP_UNSUPPORTED' && hashType === 'md4') {\r\n      if (createMd4 === undefined) {\r\n        createMd4 = require('./hash/md4');\r\n\r\n        if (BatchedHash === undefined) {\r\n          BatchedHash = require('./hash/BatchedHash');\r\n        }\r\n      }\r\n\r\n      hash = new BatchedHash(createMd4());\r\n    }\r\n\r\n    if (!hash) {\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  hash.update(buffer);\r\n\r\n  if (\r\n    digestType === 'base26' ||\r\n    digestType === 'base32' ||\r\n    digestType === 'base36' ||\r\n    digestType === 'base49' ||\r\n    digestType === 'base52' ||\r\n    digestType === 'base58' ||\r\n    digestType === 'base62'\r\n  ) {\r\n    return encodeBufferToBase(hash.digest(), digestType.substr(4)).substr(\r\n      0,\r\n      maxLength\r\n    );\r\n  } else {\r\n    return hash.digest(digestType || 'hex').substr(0, maxLength);\r\n  }\r\n}\r\n\r\nmodule.exports = getHashDigest;\r\n"]},"metadata":{},"sourceType":"script"}